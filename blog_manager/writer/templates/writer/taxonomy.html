<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Taxonomy Management</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.0/font/bootstrap-icons.css" rel="stylesheet">
    <style>
        .taxonomy-caret { display:inline-block; transition: transform .15s ease-in-out; }
        .btn.collapsed .taxonomy-caret { transform: rotate(0deg); }
        .btn:not(.collapsed) .taxonomy-caret { transform: rotate(90deg); }
    </style>
</head>
<body>
<div class="container mt-5">
    <div class="d-flex justify-content-between align-items-center mb-4">
        <h1>Taxonomy Management</h1>
        <a href="/writer/posts/" class="btn btn-outline-primary">
            <i class="bi bi-arrow-left"></i> Back to Posts
        </a>
    </div>

        <ul class="nav nav-tabs mb-3" id="taxonomyTabs" role="tablist">
            <li class="nav-item" role="presentation">
                <button class="nav-link active" id="sites-tab" data-bs-toggle="tab" data-bs-target="#sites" type="button" role="tab">Sites</button>
            </li>
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="categories-tab" data-bs-toggle="tab" data-bs-target="#categories" type="button" role="tab">Categories</button>
            </li>
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="authors-tab" data-bs-toggle="tab" data-bs-target="#authors" type="button" role="tab">Authors</button>
            </li>
        </ul>
        <div class="tab-content" id="taxonomyTabsContent">
            <div class="tab-pane fade show active" id="sites" role="tabpanel">
                <div class="card mb-3">
                    <div class="card-header">Sites</div>
                    <div class="card-body">
                        <button class="btn btn-primary btn-sm" data-bs-toggle="modal" data-bs-target="#newSite">New Site</button>
                        <div id="sitesList" class="mt-3">Loading sitesâ€¦</div>
                        <!-- Server-side fallback list (visible if JS doesn't render quickly) -->
                        <noscript>
                            <div class="list-group">
                            {% for s in sites %}
                                <div class="list-group-item d-flex justify-content-between align-items-start">
                                    <div>
                                        <div class="fw-semibold">{{ s.name }}</div>
                                        <div class="small text-muted">{{ s.domain }}</div>
                                    </div>
                                    <div>
                                        <form method="post" action="/api/blog/sites/{{ s.id }}/sync/" style="display:inline-block;">{% csrf_token %}
                                            <input type="hidden" name="mode" value="dry-run">
                                            <button class="btn btn-sm btn-outline-info">Dry-run</button>
                                        </form>
                                        <form method="post" action="/api/blog/sites/{{ s.id }}/sync/" style="display:inline-block; margin-left:.5rem;">{% csrf_token %}
                                            <input type="hidden" name="mode" value="apply">
                                            <button class="btn btn-sm btn-outline-success">Apply</button>
                                        </form>
                                    </div>
                                </div>
                            {% empty %}
                                <div class="alert alert-secondary">No sites configured</div>
                            {% endfor %}
                            </div>
                        </noscript>
                        <!-- Sync log modal -->
                        <div class="modal fade" id="siteSyncLog" tabindex="-1">
                            <div class="modal-dialog modal-xl">
                                <div class="modal-content">
                                    <div class="modal-header">
                                        <h5 class="modal-title">Sync Log</h5>
                                    </div>
                                    <div class="modal-body">
                                        <div class="mb-2 small text-muted" id="siteSyncInfo"></div>
                                        <pre id="siteSyncPre" style="height:60vh; overflow:auto; background:#111; color:#e6e6e6; padding:1rem; border-radius:4px;"></pre>
                                    </div>
                                    <div class="modal-footer">
                                        <button class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                                        <button id="siteSyncStop" class="btn btn-danger">Stop Polling</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="modal fade" id="newSite" tabindex="-1">
                            <div class="modal-dialog modal-lg">
                                <div class="modal-content">
                                    <form id="siteForm">
                                        <div class="modal-header">
                                            <h5 class="modal-title">New Site</h5>
                                        </div>
                                        <div class="modal-body">
                                            <div class="container-fluid">
                                                <div class="row g-2">
                                                    <div class="col-12 col-md-6">
                                                        <label class="form-label">Name</label>
                                                        <input name="name" class="form-control" required>
                                                    </div>
                                                    <div class="col-12 col-md-6">
                                                        <label class="form-label">Domain</label>
                                                        <input name="domain" class="form-control" required>
                                                    </div>
                                                    <div class="col-12 col-md-6">
                                                        <label class="form-label mt-2">Slug (optional)</label>
                                                        <input name="slug" class="form-control" placeholder="auto from name">
                                                    </div>
                                                    <div class="col-12 col-md-6">
                                                        <label class="form-label mt-2">Default branch</label>
                                                        <input name="default_branch" class="form-control" placeholder="main">
                                                    </div>
                                                    <div class="col-12 col-md-6">
                                                        <label class="form-label mt-2">Repo owner</label>
                                                        <input name="repo_owner" class="form-control" placeholder="github owner/org">
                                                    </div>
                                                    <div class="col-12 col-md-6">
                                                        <label class="form-label mt-2">Repo name</label>
                                                        <input name="repo_name" class="form-control" placeholder="github repo name">
                                                    </div>
                                                    <div class="col-12 col-md-6">
                                                        <label class="form-label mt-2">Posts dir</label>
                                                        <input name="posts_dir" class="form-control" placeholder="_posts">
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                        <div class="modal-footer">
                                            <button class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                                            <button class="btn btn-primary" type="submit">Save</button>
                                        </div>
                                    </form>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="tab-pane fade" id="categories" role="tabpanel">
                <div class="card mb-3">
                    <div class="card-header">Categories</div>
                    <div class="card-body">
                        <button class="btn btn-primary btn-sm" data-bs-toggle="modal" data-bs-target="#newCategory">New Category</button>
                        <div class="modal fade" id="newCategory" tabindex="-1">
                            <div class="modal-dialog">
                                <div class="modal-content">
                                    <form id="categoryForm">
                                        <div class="modal-header">
                                            <h5 class="modal-title">New Category</h5>
                                        </div>
                                        <div class="modal-body">
                                            <label class="form-label">Site</label>
                                            <select name="site" id="siteSelectCat" class="form-select" required></select>
                                            <label class="form-label mt-2">Name</label>
                                            <input name="name" class="form-control" required>
                                            <label class="form-label mt-2">Slug (auto)</label>
                                            <input name="slug" class="form-control" placeholder="auto from name">
                                        </div>
                                        <div class="modal-footer">
                                            <button class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                                            <button class="btn btn-primary" type="submit">Save</button>
                                        </div>
                                    </form>
                                </div>
                            </div>
                        </div>
                        <hr>
                        <div class="mb-2 d-flex gap-2 align-items-end">
                            <div class="flex-grow-1">
                                <label class="form-label">Filter by site</label>
                                <select id="categoriesSiteFilter" class="form-select">
                                    <option value="">All sites</option>
                                </select>
                            </div>
                            <div>
                                <button id="applyCategoriesFilter" class="btn btn-sm btn-primary">Apply</button>
                            </div>
                        </div>
                        <!-- Group by site removed: always show combined categories -->
                        <div id="categoriesList">Loading categoriesâ€¦</div>
                    </div>
                </div>
            </div>
            <div class="tab-pane fade" id="authors" role="tabpanel">
                <div class="card mb-3">
                    <div class="card-header">Authors</div>
                    <div class="card-body">
                        <button class="btn btn-primary btn-sm" data-bs-toggle="modal" data-bs-target="#newAuthor">New Author</button>
                        <div id="authorsList" class="mt-3">Loading authorsâ€¦</div>
                        <div class="modal fade" id="newAuthor" tabindex="-1">
                            <div class="modal-dialog">
                                <div class="modal-content">
                                    <form id="authorForm">
                                        <div class="modal-header">
                                            <h5 class="modal-title">New Author</h5>
                                        </div>
                                        <div class="modal-body">
                                            <label class="form-label">Site</label>
                                            <select name="site" id="siteSelectAuthor" class="form-select" required></select>
                                            <label class="form-label mt-2">Name</label>
                                            <input name="name" class="form-control" required>
                                            <label class="form-label mt-2">Slug (auto)</label>
                                            <input name="slug" class="form-control" placeholder="auto from name">
                                        </div>
                                        <div class="modal-footer">
                                            <button class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                                            <button class="btn btn-primary" type="submit">Save</button>
                                        </div>
                                    </form>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
<script>
    // Helper CSRF
    function getCookie(name) {
        const value = `; ${document.cookie}`; const parts = value.split(`; ${name}=`);
        if (parts.length === 2) return parts.pop().split(';').shift();
    }
    const csrftoken = getCookie('csrftoken');

    // map siteId -> site object (populated by populateSites)
    const sitesById = {};
    let __clusterCounter = 0;
    // currently editing site id (string) when editing; null for create
    window._editingSiteId = null;

    // Popola select Site nel modal Category
    async function populateSites() {
        const selCat = document.getElementById('siteSelectCat');
        const selAuthor = document.getElementById('siteSelectAuthor');
        if (selCat) selCat.innerHTML = '';
        if (selAuthor) selAuthor.innerHTML = '';
    // Try taxonomy endpoint first (it now returns a `sites` array). Fallback to /api/sites/.
    let sites = [];
    try {
        const taxRes = (window.WriterAPI && window.WriterAPI.apiFetch) ? await WriterAPI.apiFetch(WriterAPI.API.TAXONOMY) : await fetch('/api/blog/taxonomy/');
        if (taxRes && taxRes.ok) {
            const taxData = await taxRes.json();
            if (taxData && Array.isArray(taxData.sites) && taxData.sites.length) {
                sites = taxData.sites;
            }
        }
    } catch (err) {
        // ignore and fallback
    }
    if (!sites.length) {
        const res = (window.WriterAPI && window.WriterAPI.apiFetch) ? await WriterAPI.apiFetch(WriterAPI.API.SITES) : await fetch('/api/sites/');
        const data = await res.json();
        sites = Array.isArray(data) ? data : (data.results || []);
    }
        sites.forEach(site => {
            sitesById[site.id] = site;
            const opt = `<option value="${site.id}">${site.name}</option>`;
            if (selCat) selCat.insertAdjacentHTML('beforeend', opt);
            if (selAuthor) selAuthor.insertAdjacentHTML('beforeend', opt);
            // also populate categories site filter
            const csf = document.getElementById('categoriesSiteFilter');
            if (csf) csf.insertAdjacentHTML('beforeend', opt);
        });
            // render site list in the Sites tab
            try {
                const sitesContainer = document.getElementById('sitesList');
                if (sitesContainer) renderSitesInto(sitesContainer, sites);
            } catch (err) {
                console.warn('renderSitesInto failed', err);
            }
    }
    document.getElementById('newCategory').addEventListener('show.bs.modal', populateSites);
    document.getElementById('newAuthor').addEventListener('show.bs.modal', populateSites);

    // Creazione Site
    document.getElementById('siteForm').addEventListener('submit', async (e) => {
        e.preventDefault();
        const fd = new FormData(e.target);
        // normalize domain to include scheme if missing
        let domainVal = (fd.get('domain') || '').trim();
        if (domainVal && !/^https?:\/\//i.test(domainVal)) {
            domainVal = 'https://' + domainVal;
        }
        const payload = {
            name: fd.get('name'),
            domain: domainVal,
            slug: fd.get('slug') || null,
            repo_owner: fd.get('repo_owner') || '',
            repo_name: fd.get('repo_name') || '',
            posts_dir: fd.get('posts_dir') || '_posts',
            default_branch: fd.get('default_branch') || 'main',
        };
        // clear previous errors
        const form = e.target;
        function clearErrors() {
            form.querySelectorAll('.is-invalid').forEach(n => n.classList.remove('is-invalid'));
            form.querySelectorAll('.invalid-feedback').forEach(n => n.remove());
        }
        clearErrors();

        const doFetch = (url, opts) => (window.WriterAPI && window.WriterAPI.apiFetch) ? WriterAPI.apiFetch(url, opts) : fetch(url, opts);
        const baseEndpoint = (window.WriterAPI && window.WriterAPI.API && WriterAPI.API.SITES) ? WriterAPI.API.SITES : '/api/sites/';
        let url = baseEndpoint;
        let method = 'POST';
        // prefer global editing id (set by Edit button), fallback to form dataset
        const editingId = window._editingSiteId || form.dataset.editingSiteId;
        if (editingId) {
            url = baseEndpoint.replace(/\/$/, '') + '/' + encodeURIComponent(editingId) + '/';
            method = 'PATCH';
        }
        const res = await doFetch(url, {
            method: method,
            headers: { 'Content-Type':'application/json', 'X-CSRFToken': csrftoken },
            credentials: 'same-origin',
            body: JSON.stringify(payload)
        });

        if (res.ok) {
            // success: close modal and refresh list
            try { const modalEl = document.getElementById('newSite'); const bs = bootstrap.Modal.getInstance(modalEl); if (bs) bs.hide(); } catch (err) {}
            // reset editing state
            delete form.dataset.editingSiteId;
            window._editingSiteId = null;
            try { document.querySelector('#newSite .modal-title').textContent = 'New Site'; } catch (err) {}
            await populateSites();
            return;
        }

        // show server validation errors inline if available
        let json = null;
        try { json = await res.json(); } catch (err) { json = null; }
        if (json && typeof json === 'object') {
            // DRF validation errors usually a dict field-> [messages]
            Object.keys(json).forEach(field => {
                const input = form.querySelector(`[name="${field}"]`);
                const msgs = Array.isArray(json[field]) ? json[field] : [String(json[field])];
                if (input) {
                    input.classList.add('is-invalid');
                    const fb = document.createElement('div');
                    fb.className = 'invalid-feedback';
                    fb.textContent = msgs.join(' ');
                    input.parentNode.insertBefore(fb, input.nextSibling);
                }
            });
            return;
        }

        alert('Error creating site (server error)');
    });

    // Creazione Category
    document.getElementById('categoryForm').addEventListener('submit', async (e) => {
        e.preventDefault();
        const fd = new FormData(e.target);
        const payload = { site: Number(fd.get('site')), name: fd.get('name'), slug: fd.get('slug') || null };
        const endpoint = (window.WriterAPI && window.WriterAPI.API && WriterAPI.API.CATEGORIES) ? WriterAPI.API.CATEGORIES : '/api/blog/categories/';
        const res = (window.WriterAPI && window.WriterAPI.apiFetch) ? await WriterAPI.apiFetch(endpoint, { method: 'POST', body: JSON.stringify(payload) }) : await fetch(endpoint, {
            method: 'POST', headers: { 'Content-Type':'application/json','X-CSRFToken': csrftoken },
            credentials: 'same-origin', body: JSON.stringify(payload)
        });
        if (res.ok) { location.reload(); } else { alert('Error creating category'); }
    });

    // Creazione Author
    document.getElementById('authorForm').addEventListener('submit', async (e) => {
        e.preventDefault();
        const fd = new FormData(e.target);
        const payload = { site: fd.get('site') ? Number(fd.get('site')) : null, name: fd.get('name'), slug: fd.get('slug') || null };
        const endpointA = (window.WriterAPI && window.WriterAPI.API && WriterAPI.API.AUTHORS) ? WriterAPI.API.AUTHORS : '/api/blog/authors/';
        // Support editing: if form.dataset.editingAuthorId or global _editingAuthorId present, PATCH
        const form = e.target;
        const editingId = window._editingAuthorId || form.dataset.editingAuthorId;
        let url = endpointA;
        let method = 'POST';
        if (editingId) {
            url = endpointA.replace(/\/$/, '') + '/' + encodeURIComponent(editingId) + '/';
            method = 'PATCH';
        }
        const res = (window.WriterAPI && window.WriterAPI.apiFetch) ? await WriterAPI.apiFetch(url, { method, body: JSON.stringify(payload) }) : await fetch(url, {
            method: method, headers: { 'Content-Type':'application/json','X-CSRFToken': csrftoken },
            credentials: 'same-origin', body: JSON.stringify(payload)
        });
        if (res.ok) { 
            // close modal and refresh authors list
            try { const modalEl = document.getElementById('newAuthor'); const bs = bootstrap.Modal.getInstance(modalEl); if (bs) bs.hide(); } catch (err) {}
            try { delete form.dataset.editingAuthorId; window._editingAuthorId = null; document.querySelector('#newAuthor .modal-title').textContent = 'New Author'; } catch (err) {}
            await populateAuthors();
        } else { alert('Error creating/updating author'); }
    });

    // Populate authors list
    async function populateAuthors() {
        const container = document.getElementById('authorsList');
        if (!container) return;
        container.innerHTML = 'Loading authorsâ€¦';
        try {
            const endpoint = (window.WriterAPI && window.WriterAPI.API && WriterAPI.API.AUTHORS) ? WriterAPI.API.AUTHORS : '/api/blog/authors/';
            const res = (window.WriterAPI && window.WriterAPI.apiFetch) ? await WriterAPI.apiFetch(endpoint) : await fetch(endpoint);
            if (!res.ok) throw new Error('authors fetch failed');
            const data = await res.json();
            const authors = Array.isArray(data) ? data : (data.results || []);
            renderAuthorsInto(container, authors);
        } catch (err) {
            container.innerHTML = '<div class="alert alert-danger">Failed to load authors</div>';
            console.error(err);
        }
    }

    function renderAuthorsInto(container, authors) {
        if (!authors || !authors.length) {
            container.innerHTML = '<div class="alert alert-secondary">No authors</div>';
            return;
        }
        const list = document.createElement('div');
        list.className = 'list-group';
        authors.forEach(a => {
            const item = document.createElement('div');
            item.className = 'list-group-item d-flex justify-content-between align-items-start';
            const left = document.createElement('div');
            const siteName = a.site ? (sitesById[a.site] ? sitesById[a.site].name : ('site#' + a.site)) : '<em>global</em>';
            left.innerHTML = `<div class="fw-semibold">${a.name}</div><div class="small text-muted">${siteName}</div>`;
            const right = document.createElement('div');
            right.innerHTML = `<div class="btn-group" role="group"><button class="btn btn-sm btn-outline-secondary edit-author-btn" data-author-id="${a.id}">Edit</button><button class="btn btn-sm btn-outline-danger delete-author-btn" data-author-id="${a.id}">Delete</button></div>`;
            item.appendChild(left);
            item.appendChild(right);
            list.appendChild(item);
        });
        container.innerHTML = '';
        container.appendChild(list);
    }

    // When Authors tab is shown, load authors
    const authorsTab = document.querySelector('#authors-tab');
    if (authorsTab) {
        authorsTab.addEventListener('shown.bs.tab', populateAuthors);
    }

    // Edit / Delete handlers for authors
    document.addEventListener('click', async (e) => {
        if (e.target && e.target.classList && e.target.classList.contains('edit-author-btn')) {
            e.preventDefault();
            const id = e.target.getAttribute('data-author-id');
            // fetch author details and prefill form
            try {
                const endpoint = (window.WriterAPI && window.WriterAPI.API && WriterAPI.API.AUTHORS) ? WriterAPI.API.AUTHORS : '/api/blog/authors/';
                const url = endpoint.replace(/\/$/, '') + '/' + encodeURIComponent(id) + '/';
                const res = (window.WriterAPI && window.WriterAPI.apiFetch) ? await WriterAPI.apiFetch(url) : await fetch(url);
                if (!res.ok) throw new Error('fetch author failed');
                const a = await res.json();
                const form = document.getElementById('authorForm');
                form.dataset.editingAuthorId = id;
                window._editingAuthorId = String(id);
                form.querySelector('[name="site"]').value = a.site || '';
                form.querySelector('[name="name"]').value = a.name || '';
                form.querySelector('[name="slug"]').value = a.slug || '';
                try { document.querySelector('#newAuthor .modal-title').textContent = 'Edit Author'; } catch (err) {}
                const modalEl = document.getElementById('newAuthor');
                const bs = bootstrap.Modal.getOrCreateInstance(modalEl);
                bs.show();
            } catch (err) {
                alert('Failed to load author: ' + err);
            }
            return;
        }
        if (e.target && e.target.classList && e.target.classList.contains('delete-author-btn')) {
            e.preventDefault();
            const id = e.target.getAttribute('data-author-id');
            if (!confirm('Delete author #' + id + '?')) return;
            try {
                const endpoint = (window.WriterAPI && window.WriterAPI.API && WriterAPI.API.AUTHORS) ? WriterAPI.API.AUTHORS : '/api/blog/authors/';
                const url = endpoint.replace(/\/$/, '') + '/' + encodeURIComponent(id) + '/';
                const res = (window.WriterAPI && window.WriterAPI.apiFetch) ? await WriterAPI.apiFetch(url, { method: 'DELETE' }) : await fetch(url, { method: 'DELETE', headers: { 'X-CSRFToken': csrftoken }, credentials: 'same-origin' });
                if (res.ok || res.status === 204) {
                    await populateAuthors();
                    return;
                }
                let j = null; try { j = await res.json(); } catch (err) { j = null; }
                alert('Delete failed: ' + (j && j.detail ? j.detail : res.statusText || res.status));
            } catch (err) {
                alert('Delete failed: ' + err);
            }
            return;
        }
    });

    // Clear editing state when opening New Author modal
    const newAuthorButtons = document.querySelectorAll('[data-bs-target="#newAuthor"]');
    newAuthorButtons.forEach(btn => {
        btn.addEventListener('click', (ev) => {
            try {
                const form = document.getElementById('authorForm');
                if (form) {
                    delete form.dataset.editingAuthorId;
                    form.querySelector('[name="site"]').value = '';
                    form.querySelector('[name="name"]').value = '';
                    form.querySelector('[name="slug"]').value = '';
                }
            } catch (err) {}
            window._editingAuthorId = null;
            try { document.querySelector('#newAuthor .modal-title').textContent = 'New Author'; } catch (err) {}
        });
    });

    // Load and render categories grouped by category/subcluster
    function groupCategories(categories) {
        // Expect categories to have: id, site, name, slug
    // Derive a nested tree: category -> subcluster(s) -> leaf categories
        const groups = {};
        categories.forEach(cat => {
            const parts = (cat.name || '').split('/').map(s => s.trim()).filter(Boolean);
            if (parts.length === 0) return;
            const category = parts[0];
            const subs = parts.slice(1);
            groups[category] = groups[category] || { name: category, subs: {}, leaves: [] };
            if (subs.length === 0) {
                // Skip parent-only leaves (articles that are category root without subcluster)
                // e.g. names like 'CategoryName' or ones that include the placeholder '(no-subcluster)'
                const isParentOnly = (cat.name || '').trim() === category || (cat.name || '').includes('(no-subcluster)');
                if (!isParentOnly) {
                    groups[category].leaves.push(cat);
                }
            } else {
                // build nested path under subs (join by '/')
                const subKey = subs.join('/');
                groups[category].subs[subKey] = groups[category].subs[subKey] || { name: subKey, items: [] };
                groups[category].subs[subKey].items.push(cat);
            }
        });
        // normalize arrays
        Object.values(groups).forEach(g => {
            g.subs = Object.values(g.subs).sort((a,b)=> a.name.localeCompare(b.name));
            g.leaves = g.leaves.sort((a,b)=> a.name.localeCompare(b.name));
        });
        return groups;
    }

    function renderCategoriesInto(container, categories) {
        if (!categories || categories.length === 0) {
            container.innerHTML = '<div class="alert alert-secondary">No categories</div>';
            return;
        }
        const groups = groupCategories(categories);
        const list = document.createElement('div');
        list.className = 'list-group';
        Object.keys(groups).sort().forEach(categoryName => {
            const group = groups[categoryName];
            const item = document.createElement('div');
            item.className = 'list-group-item';
            const header = document.createElement('div');
            header.className = 'd-flex justify-content-between align-items-center';
            header.innerHTML = `<strong>${categoryName}</strong>`;
            const toggle = document.createElement('button');
            const collapseId = `category-${__clusterCounter++}`;
            toggle.className = 'btn btn-sm btn-outline-secondary collapsed';
            toggle.type = 'button';
            toggle.setAttribute('data-bs-toggle', 'collapse');
            toggle.setAttribute('data-bs-target', `#${collapseId}`);
            toggle.setAttribute('aria-expanded', 'false');
            toggle.setAttribute('aria-controls', collapseId);
            toggle.innerHTML = `<span class="taxonomy-caret">â–¸</span> <span class="visually-hidden">Toggle</span>`;
            header.appendChild(toggle);
            item.appendChild(header);

            const inner = document.createElement('div');
            inner.className = 'mt-2';
            const collapseWrap = document.createElement('div');
            collapseWrap.className = 'collapse';
            collapseWrap.id = collapseId;

            // omit parent-only leaves (articles that are 'mother' items without a subcluster)

            // render leaves (items directly under the category without subcluster)
            if (group.leaves && group.leaves.length) {
                const leavesList = document.createElement('ul');
                group.leaves.forEach(c => {
                    const li = document.createElement('li');
                    if (c && c.id) {
                        li.innerHTML = `<a href="/writer/category/${c.id}/">${c.name}</a>`;
                    } else {
                        li.textContent = c.name;
                    }
                    leavesList.appendChild(li);
                });
                inner.appendChild(leavesList);
            }

            // subclusters and their items
            if (group.subs.length) {
                group.subs.forEach(sub => {
                    const subHeader = document.createElement('div');
                    subHeader.className = 'fw-semibold mt-2';
                    subHeader.textContent = sub.name;
                    inner.appendChild(subHeader);
                    const ul = document.createElement('ul');
                        sub.items.forEach(it => {
                            const li = document.createElement('li');
                            if (it && it.id) {
                                li.innerHTML = `<a href="/writer/category/${it.id}/">${it.name}</a>`;
                            } else {
                                li.textContent = it.name;
                            }
                            ul.appendChild(li);
                        });
                    inner.appendChild(ul);
                });
            }

            // bootstrap collapse will control `collapseWrap`
            collapseWrap.appendChild(inner);
            item.appendChild(collapseWrap);

            // ensure toggle reliably controls the collapse via Bootstrap API
            try {
                toggle.addEventListener('click', (e) => {
                    e.preventDefault();
                    try {
                        const inst = bootstrap.Collapse.getOrCreateInstance(collapseWrap);
                        inst.toggle();
                    } catch (err) {
                        // fallback to toggling class if bootstrap API not available
                        collapseWrap.classList.toggle('show');
                        toggle.classList.toggle('collapsed');
                        toggle.setAttribute('aria-expanded', toggle.classList.contains('collapsed') ? 'false' : 'true');
                    }
                });
            } catch (err) {
                // ignore event attach errors
            }
            list.appendChild(item);
        });
        container.innerHTML = '';
        container.appendChild(list);
    }

    // Render list of sites into the Sites tab
    function renderSitesInto(container, sites) {
        if (!sites || !sites.length) {
            container.innerHTML = '<div class="alert alert-secondary">No sites</div>';
            return;
        }
        const list = document.createElement('div');
        list.className = 'list-group';
        sites.forEach(site => {
            const item = document.createElement('div');
            item.className = 'list-group-item d-flex justify-content-between align-items-start';
            const left = document.createElement('div');
            left.innerHTML = `<div class="fw-semibold">${site.name}</div><div class="small text-muted">${site.domain || ''}</div>`;
                        const right = document.createElement('div');
                        // On small screens, collapse the action buttons into a single "Actions" dropdown
                        const isSmall = (window.matchMedia && window.matchMedia('(max-width:768px)').matches);
                        if (isSmall) {
                                right.innerHTML = `
                                        <div class="btn-group ms-2">
                                            <div class="dropdown">
                                                <button class="btn btn-sm btn-outline-secondary dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false">Actions</button>
                                                <ul class="dropdown-menu dropdown-menu-end">
                                                    <li><button class="dropdown-item edit-site-btn" data-site-id="${site.id}">Edit</button></li>
                                                    <li><button class="dropdown-item delete-site-btn" data-site-id="${site.id}">Delete</button></li>
                                                    <li><hr class="dropdown-divider"></li>
                                                    <li><button class="dropdown-item site-sync-btn" data-site-id="${site.id}" data-mode="dry-run">Dry-run</button></li>
                                                    <li><button class="dropdown-item site-sync-btn" data-site-id="${site.id}" data-mode="apply">Apply</button></li>
                                                </ul>
                                            </div>
                                        </div>
                                `;
                        } else {
                                right.innerHTML = `<div class="btn-group" role="group"><button class="btn btn-sm btn-outline-secondary edit-site-btn" data-site-id="${site.id}">Edit</button><button class="btn btn-sm btn-outline-danger delete-site-btn" data-site-id="${site.id}">Delete</button></div>`;
                                // add sync buttons group for desktop
                                const syncGroup = document.createElement('div');
                                syncGroup.className = 'btn-group ms-2';
                                syncGroup.innerHTML = `<button class="btn btn-sm btn-outline-info site-sync-btn" data-site-id="${site.id}" data-mode="dry-run">Dry-run</button><button class="btn btn-sm btn-outline-success site-sync-btn" data-site-id="${site.id}" data-mode="apply">Apply</button>`;
                                right.appendChild(syncGroup);
                        }
            item.appendChild(left);
            item.appendChild(right);
            list.appendChild(item);
        });
        container.innerHTML = '';
        container.appendChild(list);
    }

    // Edit / Delete handlers for sites
    document.addEventListener('click', async (e) => {
        // Edit site: prefill modal and open
        if (e.target && e.target.classList && e.target.classList.contains('edit-site-btn')) {
            e.preventDefault();
            const id = e.target.getAttribute('data-site-id');
            const site = sitesById[id];
            if (!site) return alert('Site data not loaded');
            // populate form
            const form = document.getElementById('siteForm');
            form.dataset.editingSiteId = id;
            window._editingSiteId = String(id);
            form.querySelector('[name="name"]').value = site.name || '';
            form.querySelector('[name="domain"]').value = site.domain || '';
            const slugInput = form.querySelector('[name="slug"]'); if (slugInput) slugInput.value = site.slug || '';
            const repoOwner = form.querySelector('[name="repo_owner"]'); if (repoOwner) repoOwner.value = site.repo_owner || '';
            const repoName = form.querySelector('[name="repo_name"]'); if (repoName) repoName.value = site.repo_name || '';
            const postsDir = form.querySelector('[name="posts_dir"]'); if (postsDir) postsDir.value = site.posts_dir || '';
            const defBranch = form.querySelector('[name="default_branch"]'); if (defBranch) defBranch.value = site.default_branch || '';
            // change modal title
            try { document.querySelector('#newSite .modal-title').textContent = 'Edit Site'; } catch (err) {}
            // show modal
            try { const modalEl = document.getElementById('newSite'); const bs = bootstrap.Modal.getOrCreateInstance(modalEl); bs.show(); } catch (err) {}
            return;
        }

        // Delete site
        if (e.target && e.target.classList && e.target.classList.contains('delete-site-btn')) {
            e.preventDefault();
            const id = e.target.getAttribute('data-site-id');
            if (!confirm('Delete site #' + id + '? This cannot be undone.')) return;
            const endpointBase = (window.WriterAPI && window.WriterAPI.API && WriterAPI.API.SITES) ? WriterAPI.API.SITES : '/api/sites/';
            const url = endpointBase.replace(/\/$/, '') + '/' + encodeURIComponent(id) + '/';
            try {
                const res = (window.WriterAPI && window.WriterAPI.apiFetch) ? await WriterAPI.apiFetch(url, { method: 'DELETE' }) : await fetch(url, { method: 'DELETE', headers: { 'X-CSRFToken': csrftoken }, credentials: 'same-origin' });
                if (res.ok || res.status === 204) {
                    // refresh list
                    await populateSites();
                    return;
                }
                let j = null;
                try { j = await res.json(); } catch (err) { j = null; }
                alert('Delete failed: ' + (j && j.detail ? j.detail : res.statusText || res.status));
            } catch (err) {
                alert('Delete failed: ' + err);
            }
        }
        // Site sync buttons
        if (e.target && e.target.classList && e.target.classList.contains('site-sync-btn')) {
            e.preventDefault();
            const id = e.target.getAttribute('data-site-id');
            const mode = e.target.getAttribute('data-mode') || 'dry-run';
            const endpoint = (window.WriterAPI && window.WriterAPI.API && WriterAPI.API.TAXONOMY) ? WriterAPI.API.TAXONOMY : '/api/blog/';
            // use site sync endpoint
            const url = `/api/blog/sites/${encodeURIComponent(id)}/sync/`;
            try {
                const res = (window.WriterAPI && window.WriterAPI.apiFetch) ? await WriterAPI.apiFetch(url, { method: 'POST', body: JSON.stringify({ mode }) }) : await fetch(url, { method: 'POST', headers: { 'Content-Type':'application/json','X-CSRFToken': csrftoken }, credentials: 'same-origin', body: JSON.stringify({ mode }) });
                if (!res.ok) {
                    let j = null; try { j = await res.json(); } catch (err) { j = null; }
                    return alert('Failed to start sync: ' + (j && j.detail ? j.detail : res.statusText || res.status));
                }
                const j = await res.json();
                const runId = j.run_id;
                const logPath = j.log_path;
                // show modal and start polling
                const pre = document.getElementById('siteSyncPre');
                const info = document.getElementById('siteSyncInfo');
                pre.textContent = j.initial_log || '';
                info.textContent = `Site: ${sitesById[id] ? sitesById[id].name : id} â€” mode: ${mode} â€” run: ${runId}`;
                const modalEl = document.getElementById('siteSyncLog');
                const bs = bootstrap.Modal.getOrCreateInstance(modalEl);
                bs.show();
                let polling = true;
                const stopBtn = document.getElementById('siteSyncStop');
                const tailUrl = `/api/blog/sites/${encodeURIComponent(id)}/sync/tail/?run_id=${encodeURIComponent(runId)}`;
                const poll = async () => {
                    if (!polling) return;
                    try {
                        const r = (window.WriterAPI && window.WriterAPI.apiFetch) ? await WriterAPI.apiFetch(tailUrl) : await fetch(tailUrl, { credentials: 'same-origin' });
                        if (r.ok) {
                            const data = await r.json();
                            if (data && data.log !== undefined) {
                                pre.textContent = data.log;
                                pre.scrollTop = pre.scrollHeight;
                            }
                        }
                    } catch (err) {
                        console.warn('poll tail failed', err);
                    }
                    if (polling) setTimeout(poll, 2000);
                };
                stopBtn.onclick = () => { polling = false; };
                poll();
            } catch (err) {
                alert('Failed to start sync: ' + err);
            }
            return;
        }
    });

    // When opening New Site via the dedicated button, clear editing state
    const newSiteButtons = document.querySelectorAll('[data-bs-target="#newSite"]');
    newSiteButtons.forEach(btn => {
        btn.addEventListener('click', (ev) => {
            try {
                const form = document.getElementById('siteForm');
                if (form) {
                    delete form.dataset.editingSiteId;
                }
            } catch (err) {}
            window._editingSiteId = null;
            try { document.querySelector('#newSite .modal-title').textContent = 'New Site'; } catch (err) {}
        });
    });

    async function loadCategories() {
        const container = document.getElementById('categoriesList');
        container.innerHTML = 'Loading categoriesâ€¦';
        try {
            const csf = document.getElementById('categoriesSiteFilter');
            const siteFilter = csf ? csf.value : '';
            let endpoint = (window.WriterAPI && window.WriterAPI.API && WriterAPI.API.CATEGORIES) ? WriterAPI.API.CATEGORIES : '/api/blog/categories/';
            if (siteFilter) {
                // API supports filter via ?site=<id>
                endpoint = endpoint + '?site=' + encodeURIComponent(siteFilter);
            }
            // Fetch all pages (DRF pagination may limit results). Use page_size param if available.
            const categories = await fetchAllCategories(endpoint, siteFilter);
            // Try server-side grouped taxonomy first
            let serverTax = null;
            try {
                serverTax = await fetchServerTaxonomy(siteFilter);
            } catch (err) {
                console.warn('server taxonomy fetch failed', err);
            }
            // Debug: log counts and distinct site ids
            try {
                const siteIds = Array.from(new Set(categories.map(c => c.site).filter(Boolean)));
                console.log('taxonomy: fetched categories', categories.length, 'distinct sites', siteIds);
                const info = document.createElement('div');
                info.className = 'mb-2 small text-muted';
                info.textContent = `Found ${categories.length} categories across ${siteIds.length} sites (ids: ${siteIds.join(', ')})`;
                container.innerHTML = '';
                container.appendChild(info);
            } catch (err) {
                console.warn('taxonomy debug failed', err);
            }
            // Wait for sites to be populated (so we can display site names if needed)
            await populateSitesPromise;
            // If server returned grouped taxonomy, prefer it (authoritative)
            if (serverTax && serverTax.categories && serverTax.categories.length) {
                container.innerHTML = '';
                const info2 = document.createElement('div');
                info2.className = 'mb-2 small text-muted';
                info2.textContent = `Server-side grouped taxonomy (categories: ${serverTax.categories.length})`;
                container.appendChild(info2);
                renderServerTaxonomy(container, serverTax, categories);
                return;
            }

            // Try to build taxonomy from posts' front-matter as fallback
            let postsTax = [];
            try {
                postsTax = await buildTaxonomyFromPosts(siteFilter);
            } catch (err) {
                console.warn('buildTaxonomyFromPosts failed', err);
            }
            if (postsTax && postsTax.length && postsTax.length > categories.length) {
                container.innerHTML = '';
                const info2 = document.createElement('div');
                info2.className = 'mb-2 small text-muted';
                info2.textContent = `Built taxonomy from posts-derived ${postsTax.length} entries (preferred)`;
                container.appendChild(info2);
                renderCategoriesInto(container, postsTax);
            } else {
                // Default: render combined flat list (show all categories returned by the API)
                renderCategoriesInto(container, categories);
            }
        } catch (err) {
            container.innerHTML = '<div class="alert alert-danger">Failed to load categories</div>';
            console.error(err);
        }
    }

    // Fetch server-side grouped taxonomy endpoint
    async function fetchServerTaxonomy(siteFilter=''){
        const base = (window.WriterAPI && window.WriterAPI.API && WriterAPI.API.TAXONOMY) ? WriterAPI.API.TAXONOMY : '/api/blog/taxonomy/';
        let url = base;
        if (siteFilter) url = url + '?site=' + encodeURIComponent(siteFilter);
        const res = (window.WriterAPI && window.WriterAPI.apiFetch) ? await WriterAPI.apiFetch(url) : await fetch(url);
        if (!res.ok) throw new Error('server taxonomy request failed');
        return await res.json();
    }

    // Render server-side grouped taxonomy (categories -> subclusters)
    function renderServerTaxonomy(container, data, categoriesList) {
        // data: { site: <id|null>, categories: [ {category, subclusters:[{name,count,examples}]} ] }
        // categoriesList: optional array of Category objects from the API (id, name, slug)
        const list = document.createElement('div');
        list.className = 'list-group';
        (data.categories || []).forEach((catObj, idx) => {
            const categoryName = catObj.category || catObj.name || ('Category ' + idx);
            const item = document.createElement('div');
            item.className = 'list-group-item';
            const header = document.createElement('div');
            header.className = 'd-flex justify-content-between align-items-center';
            // attempt to find a Category id for this categoryName
            let parentCat = null;
            if (Array.isArray(categoriesList)) parentCat = categoriesList.find(c => (c.name||'').trim() === categoryName);
            if (parentCat) {
                header.innerHTML = `<strong><a href="/writer/category/${parentCat.id}/">${categoryName}</a></strong>`;
            } else {
                header.innerHTML = `<strong>${categoryName}</strong>`;
            }
            const toggle = document.createElement('button');
            const collapseId = `srv-cat-${__clusterCounter++}`;
            toggle.className = 'btn btn-sm btn-outline-secondary collapsed';
            toggle.type = 'button';
            toggle.setAttribute('data-bs-toggle', 'collapse');
            toggle.setAttribute('data-bs-target', `#${collapseId}`);
            toggle.setAttribute('aria-expanded', 'false');
            toggle.setAttribute('aria-controls', collapseId);
            toggle.innerHTML = `<span class="taxonomy-caret">â–¸</span> <span class="visually-hidden">Toggle</span>`;
            header.appendChild(toggle);
            item.appendChild(header);

            const collapseWrap = document.createElement('div');
            collapseWrap.className = 'collapse mt-2';
            collapseWrap.id = collapseId;
            // subclusters
            (catObj.subclusters || []).forEach(sub => {
                const sname = (sub && sub.name) ? String(sub.name).trim() : '';
                if (!sname || sname === '(no-subcluster)') return; // skip placeholder
                const subHeader = document.createElement('div');
                subHeader.className = 'fw-semibold mt-2';
                // try to find matching Category row for this subcluster
                let subCat = null;
                if (parentCat && Array.isArray(categoriesList)) {
                    const expected = `${parentCat.name}/${sname}`;
                    subCat = categoriesList.find(c => (c.name||'').trim() === expected);
                } else if (Array.isArray(categoriesList)) {
                    // fallback: try find any category matching 'Category/Sub'
                    const expected2 = `${categoryName}/${sname}`;
                    subCat = categoriesList.find(c => (c.name||'').trim() === expected2);
                }
                if (subCat && parentCat) {
                    subHeader.innerHTML = `<a href="/writer/category/${parentCat.id}/sub/${subCat.id}/">${sname}</a>`;
                } else if (subCat) {
                    // no parent id, link directly to sub by its id using parent id equal to subCat id (best-effort)
                    subHeader.innerHTML = `<a href="/writer/category/${subCat.id}/">${sname}</a>`;
                } else {
                    subHeader.textContent = sname;
                }
                collapseWrap.appendChild(subHeader);
                // omit article examples list for a cleaner taxonomy UI
            });

            item.appendChild(collapseWrap);
            try {
                toggle.addEventListener('click', (e) => {
                    e.preventDefault();
                    try {
                        const inst = bootstrap.Collapse.getOrCreateInstance(collapseWrap);
                        inst.toggle();
                    } catch (err) {
                        collapseWrap.classList.toggle('show');
                        toggle.classList.toggle('collapsed');
                        toggle.setAttribute('aria-expanded', toggle.classList.contains('collapsed') ? 'false' : 'true');
                    }
                });
            } catch (err) {}
            list.appendChild(item);
        });
        container.innerHTML = '';
        container.appendChild(list);
    }

    // --- Posts-based taxonomy builder ---
    function extractFrontMatter(text) {
        if (!text) return null;
        const m = text.match(/^\s*---\s*\n([\s\S]*?)\n---\s*\n/);
        if (!m) return null;
        return m[1];
    }

    function parseFMForCluster(fmText) {
        const out = { categories: [], clusters: [] };
        const lines = (fmText || '').split(/\r?\n/);
        let key = null;
        for (let i=0;i<lines.length;i++){
            const raw = lines[i];
            const line = raw.trim();
            if (!line) { key = null; continue; }
            const kv = line.match(/^([a-zA-Z0-9_\-]+):\s*(.*)$/);
            if (kv) {
                key = kv[1];
                let val = kv[2] || '';
                if (val === '') {
                    // read list items
                    const arr = [];
                    let j = i+1;
                    for (; j<lines.length; j++){
                        const sub = lines[j];
                        if (/^\s*-\s+/.test(sub)) {
                            arr.push(sub.replace(/^\s*-\s+/, '').trim());
                        } else if (/^\s/.test(sub)) {
                            continue;
                        } else break;
                    }
                    i = j-1;
                    val = arr.length ? arr : '';
                }
                if (key === 'cluster') {
                    if (Array.isArray(val)) out.clusters.push(...val.filter(Boolean));
                    else if (typeof val === 'string' && val) out.clusters.push(val);
                } else if (key === 'subcluster') {
                    if (Array.isArray(val)) out.clusters.push(...val.filter(Boolean));
                    else if (typeof val === 'string' && val) out.clusters.push(val);
                } else if (key === 'categories') {
                    if (Array.isArray(val)) out.categories.push(...val.filter(Boolean));
                    else if (val) out.categories.push(val);
                }
            } else if (/^\-\s+/.test(line) && key) {
                const v = line.replace(/^\-\s+/, '').trim();
                if (key === 'cluster') out.clusters.push(v);
                if (key === 'subcluster') out.clusters.push(v);
                if (key === 'categories') out.categories.push(v);
            } else {
                key = null;
            }
        }
        return out;
    }

    async function fetchPosts(siteFilter=''){
        const endpointBase = (window.WriterAPI && window.WriterAPI.API && WriterAPI.API.POSTS) ? WriterAPI.API.POSTS : '/api/blog/posts/';
        const qp = siteFilter ? `?site=${encodeURIComponent(siteFilter)}&page_size=1000` : '?page_size=1000';
        const endpoint = endpointBase + qp;
        const res = (window.WriterAPI && window.WriterAPI.apiFetch) ? await WriterAPI.apiFetch(endpoint) : await fetch(endpoint);
        const data = await res.json();
        return Array.isArray(data) ? data : (data.results || []);
    }

    // Fetch all posts following pagination (like fetchAllCategories)
    async function fetchAllPosts(siteFilter=''){
        const endpointBase = (window.WriterAPI && window.WriterAPI.API && WriterAPI.API.POSTS) ? WriterAPI.API.POSTS : '/api/blog/posts/';
        const sep = endpointBase.includes('?') ? '&' : '?';
        const qp = siteFilter ? `site=${encodeURIComponent(siteFilter)}&page_size=1000` : 'page_size=1000';
        const first = endpointBase + sep + qp;
        let res = (window.WriterAPI && window.WriterAPI.apiFetch) ? await WriterAPI.apiFetch(first) : await fetch(first);
        if (!res.ok) {
            res = (window.WriterAPI && window.WriterAPI.apiFetch) ? await WriterAPI.apiFetch(endpointBase) : await fetch(endpointBase);
        }
        let data = await res.json();
        if (Array.isArray(data)) return data;
        const items = [];
        items.push(...(data.results || []));
        let next = data.next;
        while (next) {
            try {
                const nextUrl = new URL(next, window.location.origin);
                if (siteFilter && !nextUrl.searchParams.has('site')) {
                    nextUrl.searchParams.set('site', siteFilter);
                }
                const r = (window.WriterAPI && window.WriterAPI.apiFetch) ? await WriterAPI.apiFetch(nextUrl.toString()) : await fetch(nextUrl.toString());
                const d = await r.json();
                items.push(...(d.results || []));
                next = d.next;
            } catch (err) {
                console.warn('fetchAllPosts follow-next failed', err);
                break;
            }
        }
        return items;
    }

    // Fetch all categories from a potentially paginated endpoint
    async function fetchAllCategories(baseEndpoint, siteFilter=''){
        const items = [];
        // try to add a large page_size param first
        const sep = baseEndpoint.includes('?') ? '&' : '?';
        let endpoint = baseEndpoint + sep + 'page_size=1000';
        let res = (window.WriterAPI && window.WriterAPI.apiFetch) ? await WriterAPI.apiFetch(endpoint) : await fetch(endpoint);
        if (!res.ok) {
            // fallback to non-paginated attempt
            res = (window.WriterAPI && window.WriterAPI.apiFetch) ? await WriterAPI.apiFetch(baseEndpoint) : await fetch(baseEndpoint);
        }
        let data = await res.json();
        if (Array.isArray(data)) return data;
        const results = data.results || [];
        items.push(...results);
        // follow next links if present, preserving siteFilter
        let next = data.next;
        while (next) {
            try {
                const nextUrl = new URL(next, window.location.origin);
                if (siteFilter && !nextUrl.searchParams.has('site')) {
                    nextUrl.searchParams.set('site', siteFilter);
                }
                const r = (window.WriterAPI && window.WriterAPI.apiFetch) ? await WriterAPI.apiFetch(nextUrl.toString()) : await fetch(nextUrl.toString());
                const d = await r.json();
                items.push(...(d.results || []));
                next = d.next;
            } catch (err) {
                console.warn('fetchAllCategories follow-next failed', err);
                break;
            }
        }
        return items;
    }

    async function buildTaxonomyFromPosts(siteFilter=''){
        try {
            const posts = await fetchAllPosts(siteFilter);
            const entries = new Set();
            // For mapping cluster -> set(subcluster)
            const clusterMap = {};
            posts.forEach(p => {
                const raw = p.content || p.body || p.content || '';
                const fm = extractFrontMatter(raw);
                if (!fm) return;
                // crude per-post parse to extract cluster, subcluster, categories preserving association
                const lines = fm.split(/\r?\n/).map(l=>l.trim());
                let key = null;
                const local = { cluster: [], subcluster: [], categories: [] };
                for (let i=0;i<lines.length;i++){
                    const line = lines[i];
                    if (!line) { key = null; continue; }
                    const m = line.match(/^([a-zA-Z0-9_\-]+):\s*(.*)$/);
                    if (m) {
                        key = m[1];
                        let val = m[2] || '';
                        if (val === '') {
                            // collect list entries
                            let j=i+1; const arr=[];
                            for (; j<lines.length; j++){
                                const sub = lines[j];
                                if (/^\-\s+/.test(sub)) arr.push(sub.replace(/^\-\s+/, '').trim());
                                else if (/^\s/.test(sub)) continue; else break;
                            }
                            i = j-1;
                            val = arr;
                        }
                        if (key === 'cluster') {
                            if (Array.isArray(val)) local.cluster.push(...val);
                            else if (val) local.cluster.push(val);
                        } else if (key === 'subcluster') {
                            if (Array.isArray(val)) local.subcluster.push(...val);
                            else if (val) local.subcluster.push(val);
                        } else if (key === 'categories') {
                            if (Array.isArray(val)) local.categories.push(...val);
                            else if (val) local.categories.push(val);
                        }
                    } else if (/^\-\s+/.test(line) && key) {
                        const v = line.replace(/^\-\s+/, '').trim();
                        if (key === 'cluster') local.cluster.push(v);
                        if (key === 'subcluster') local.subcluster.push(v);
                        if (key === 'categories') local.categories.push(v);
                    } else {
                        key = null;
                    }
                }

                // build mapping
                const clusters = local.cluster.length ? local.cluster : [];
                const subs = local.subcluster.length ? local.subcluster : [];
                const cats = local.categories.length ? local.categories : [];
                if (clusters.length === 0 && subs.length === 0 && cats.length>0) {
                    // categories without cluster -> add them as top-level
                    cats.forEach(cat => entries.add(cat));
                }
                clusters.forEach(cl => {
                    const cln = cl;
                    clusterMap[cln] = clusterMap[cln] || new Set();
                    if (subs.length) {
                        subs.forEach(su => clusterMap[cln].add(su));
                    }
                    if (cats.length) {
                        cats.forEach(cat => clusterMap[cln].add(cat));
                    }
                });
            });

            // flatten to names 'cluster' and 'cluster/sub'
            Object.keys(clusterMap).forEach(cl => {
                entries.add(cl);
                Array.from(clusterMap[cl]).forEach(sub => {
                    if (sub && sub !== cl) entries.add(`${cl}/${sub}`);
                });
            });

            return Array.from(entries).map(name => ({ id: name, name: name, slug: name.replace(/\s+/g,'-').toLowerCase() }));
        } catch (err) {
            console.warn('fetchPosts/buildTaxonomyFromPosts failed', err);
            return [];
        }
    }

    // Load categories when the Categories tab is shown
    const categoriesTab = document.querySelector('#categories-tab');
    if (categoriesTab) {
        categoriesTab.addEventListener('shown.bs.tab', loadCategories);
    }

    // Apply filter handlers
    document.addEventListener('click', (e) => {
        if (e.target && e.target.id === 'applyCategoriesFilter') {
            e.preventDefault();
            loadCategories();
        }
    });
    const csfElem = document.getElementById('categoriesSiteFilter');
    if (csfElem) {
        csfElem.addEventListener('change', () => {
            // auto-apply on change
            loadCategories();
        });
    }

    // Ensure site list is populated for the category filter and mapping
    // immediately (so loadCategories can reference `sitesById`).
    const populateSitesPromise = populateSites().catch(err => { console.warn('populateSites failed', err); return []; });
    // After sites are loaded, pre-populate authors if the Authors tab is currently active
    populateSitesPromise.then(() => {
        try {
            const active = document.querySelector('#authors-tab');
            // if authors tab exists and is active, load authors immediately
            if (active && active.classList.contains('active')) {
                populateAuthors();
            }
        } catch (err) {}
    });

    // Re-render Sites actions on resize to toggle dropdown vs inline buttons
    let _sitesLastSmall = (window.matchMedia && window.matchMedia('(max-width:768px)').matches);
    function _maybeReflowSites() {
        const isSmall = (window.matchMedia && window.matchMedia('(max-width:768px)').matches);
        if (isSmall === _sitesLastSmall) return;
        _sitesLastSmall = isSmall;
        // force re-populate of sites list to apply new markup
        populateSites().catch(err => console.warn('populateSites reflow failed', err));
    }
    window.addEventListener('resize', () => {
        // debounce
        clearTimeout(window._siteReflowTimer);
        window._siteReflowTimer = setTimeout(_maybeReflowSites, 150);
    });
</script>
</body>
</html>
